use std::collections::BTreeMap;

use reqwest::StatusCode;
use serde::Deserialize;


const ENTITIES_JSON_URL: &str = "https://html.spec.whatwg.org/entities.json";


#[derive(Clone, Debug, Default, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct EntityDefinition {
    pub codepoints: Vec<u32>,
    pub characters: String,
}


async fn run() {
    // obtain entities JSON data
    let response = reqwest::get(ENTITIES_JSON_URL).await
        .expect("failed to obtain entities");
    if response.status() != StatusCode::OK {
        panic!("received HTTP status code {} when attempting to obtain entities", response.status());
    }
    let response_bytes = response.bytes().await
        .expect("failed to obtain entities");
    let response_str = std::str::from_utf8(&response_bytes)
        .expect("failed to decode entities as UTF-8");
    let mut definitions: BTreeMap<String, EntityDefinition> = serde_json::from_str(response_str)
        .expect("failed to parse entities as JSON");

    // we have a few hyperlegacy definitions without a semicolon
    // ("&ent" instead of "&ent;")
    // if "&ent;" exists as well, drop "&ent"
    // otherwise, transform it into "&ent;"
    let def_keys: Vec<String> = definitions.keys()
        .map(|k| k.clone())
        .collect();
    for def_key in &def_keys {
        if !def_key.ends_with(";") {
            let mut semi_key = def_key.clone();
            semi_key.push(';');
            if definitions.contains_key(&semi_key) {
                // good, delete def_key
                definitions.remove(def_key);
            } else {
                // replace def_key with semi_key
                let definition = definitions.remove(def_key).unwrap();
                definitions.insert(semi_key, definition);
            }
        }
    }

    println!("// this file has been generated by a complete tool from {:?}", ENTITIES_JSON_URL);
    println!("pub fn get_entities() -> ::std::collections::HashMap<&'static str, &'static str> {{");
    println!("    let mut ret = ::std::collections::HashMap::with_capacity({});", definitions.len());
    for (key, definition) in &definitions {
        print!("    ret.insert({:?}, \"", key);
        for codepoint in &definition.codepoints {
            // hex entities become shorter at decimal 1000000
            if *codepoint < 1000000 {
                print!("&#{};", codepoint);
            } else {
                print!("&#x{:X};", codepoint);
            }
        }
        println!("\");");
    }
    println!("    ret");
    println!("}}");
}


#[tokio::main]
async fn main() {
    run().await
}
